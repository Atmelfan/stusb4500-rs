//! STUSB4500 utilities
//!
//! This utility is intended to run on a linux host (e.g. a Raspberry Pi) and can read,
//! write the NVM over IÂ²C as well as show status.
//!
//! [gui]: https://www.st.com/en/embedded-software/stsw-stusb002.html

use clap::{Parser, Subcommand};
use std::fs::File;
use std::io::{Read, Write};
use std::path::PathBuf;
use stusb4500::{pdo, Address, PdoChannel, STUSB4500, STUSB4500_ADDR};

use linux_embedded_hal::I2cdev;

const I2C_BUS: &str = "i2c-0";

const DEFAULT_NVM_DATA: [[u8; 8]; 5] = [
    [0x00, 0x00, 0xB0, 0xAB, 0x00, 0x45, 0x00, 0x00],
    [0x10, 0x40, 0x9C, 0x1C, 0xFF, 0x01, 0x3C, 0xDF],
    [0x02, 0x40, 0x0F, 0x00, 0x32, 0x00, 0xFC, 0xF1],
    [0x00, 0x19, 0x56, 0xAF, 0xF5, 0x35, 0x5F, 0x00],
    [0x00, 0x4B, 0x90, 0x21, 0x43, 0x00, 0x40, 0xFB],
];

/// Utility to read and write STUSB4500 NVM
#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Turn debugging information on
    #[arg(short, action = clap::ArgAction::Count)]
    verbosity: u8,

    /// Turn off all standard output
    #[arg(short, long)]
    silent: bool,

    /// Optional I2C bus for access to stusb4500. Can be either the bus name or absolute path.
    /// Defaults to i2c-0
    #[arg(short, long, default_value=I2C_BUS)]
    bus: String,

    /// Optional I2C address.
    /// Defaults to 40 (0x28)
    #[arg(short, long, default_value_t=STUSB4500_ADDR)]
    address: u8,

    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    /// Read register block from STUSB4500 NVM
    Read {
        /// Sets an input file
        #[arg(short, long, value_name = "FILE")]
        file: Option<PathBuf>,
    },
    /// Write register block to STUSB4500 NVM
    Write {
        /// Set a custom output file
        #[arg(short, long, value_name = "FILE")]
        file: PathBuf,
    },
    /// Write factory reset register block to STUSB4500 NVM
    /// as generated by the ST GUI application - so be careful.
    FactoryReset,
    /// Show status information
    Status,
}

fn main() {
    let cli = Cli::parse();

    env_logger::Builder::new()
        .filter_level(match (cli.verbosity, cli.silent) {
            (_, true) => log::LevelFilter::Off,
            (0, _) => log::LevelFilter::Info,
            (1, _) => log::LevelFilter::Debug,
            (2.., _) => log::LevelFilter::Trace,
        })
        .init();
    println!("{:?}", log::max_level());

    // Instantiate the device driver
    let mut bus_path = PathBuf::from("/dev/");
    bus_path = bus_path.join(cli.bus);
    let mut stusb = STUSB4500::new(
        I2cdev::new(bus_path).unwrap(),
        Address::Custom(cli.address & 0x7F),
    );

    // You can check for the existence of subcommands, and if found use their
    // matches just as you would the top level cmd
    match &cli.command.unwrap_or(Commands::Status {}) {
        Commands::Read { file } => {
            log::info!("Reading NVM data:");

            let mut nvm = stusb.unlock_nvm().expect("Failed to unlock NVM");
            let sectors = nvm.read_sectors().expect("Failed to read sectors");
            nvm.lock().expect("Failed to lock NVM");

            if let Some(dereffile) = file.as_deref() {
                let mut f = File::create(dereffile).expect("Couldn't create file");
                sectors.iter().for_each(|sector| {
                    f.write_all(sector).expect("Failed to write");
                });
            } else {
                sectors.iter().for_each(|sector| {
                    sector.iter().for_each(|byte| print!(" 0x{:02X}", byte));
                    println!();
                });
            }
        }
        Commands::Write { file } => {
            // Read the file
            let mut f = File::open(file).expect("File not found");

            let mut buffer: [u8; 40] = [0; 40];
            f.read(&mut buffer).expect("Buffer overflow");
            let mut sectors: [[u8; 8]; 5] = [[0; 8]; 5];

            for slice in 0..5 {
                for idx in 0..8 {
                    sectors[slice][idx] = buffer[8 * slice + idx];
                }
            }

            log::info!("Writing NVM data...");
            let mut nvm = stusb.unlock_nvm().expect("Failed to unlock NVM");
            nvm.write_sectors(sectors).expect("Failed to write NVM");
            nvm.lock().expect("Failed to lock NVM");
            log::info!("Done");
        }
        Commands::FactoryReset => {
            log::info!("Writing factory default NVM data...");
            let mut nvm = stusb.unlock_nvm().expect("Failed to unlock NVM");
            nvm.write_sectors(DEFAULT_NVM_DATA)
                .expect("Failed to write NVM");
            nvm.lock().expect("Failed to lock NVM");
            log::info!("Done");
        }
        Commands::Status => {
            for (n, ch) in [PdoChannel::PDO1, PdoChannel::PDO2, PdoChannel::PDO3]
                .iter()
                .enumerate()
            {
                println!("PDO{n}:");
                print_pdo(&stusb.get_pdo(*ch).expect("Failed to read PDO"));
                println!();
            }

            let voltage = stusb.get_voltage().expect("Failed to read voltage");
            println!("Current Voltage {} V", voltage);
            println!();

            let current_rdo = stusb.get_current_rdo().expect("Failed to read PDO");
            println!("Current RDO:");
            println!("- position                    {}", current_rdo.position());
            println!("- give_back                   {}", current_rdo.give_back());
            println!(
                "- capability_mismatch         {}",
                current_rdo.capability_mismatch()
            );
            println!(
                "- usb_communication_capable   {}",
                current_rdo.usb_communication_capable()
            );
            println!(
                "- no_usb_suspend              {}",
                current_rdo.no_usb_suspend()
            );
            println!(
                "- unchunked_extended_messages {}",
                current_rdo.unchunked_extended_messages()
            );
            println!(
                "- operating_current           {:.2} A",
                current_rdo.operating_current() as f64 / 100.0
            );
            println!(
                "- max_operating_currernt      {:.2} A",
                current_rdo.max_operating_current() as f64 / 100.0
            );
        }
    }
}

fn print_pdo(pdo: &pdo::Pdo) {
    match pdo {
        pdo::Pdo::Fixed(pdo) => {
            println!("- type                          Fixed");
            println!(
                "- higher_capability             {}",
                pdo.higher_capability()
            );
            println!(
                "- unconstrained_power           {}",
                pdo.unconstrained_power()
            );
            println!(
                "- usb_communications_capable    {}",
                pdo.usb_communications_capable()
            );
            println!("- dual_role_data                {}", pdo.dual_role_data());
            println!("- fast_role_swap                {}", pdo.fast_role_swap());
            println!(
                "- voltage                       {:.2} V",
                pdo.voltage() as f32 / 20.0
            );
            println!(
                "- current                       {:.2} A",
                pdo.current() as f32 / 100.0
            );
        }
        pdo::Pdo::Variable(pdo) => {
            println!("- type                          Variable");
            println!("- voltage:");
            println!(
                "  max                           {:.2} V",
                pdo.max_voltage() as f32 / 20.0
            );
            println!(
                "  min                           {:.2} V",
                pdo.min_voltage() as f32 / 20.0
            );
            println!(
                "- current                       {:.2} A",
                pdo.current() as f32 / 100.0
            );
        }
        pdo::Pdo::Battery(pdo) => {
            println!("- type                          Battery");
            println!("- voltage:");
            println!(
                "  max                           {:.2} V",
                pdo.max_voltage() as f32 / 20.0
            );
            println!(
                "  min                           {:.2} V",
                pdo.min_voltage() as f32 / 20.0
            );
            println!(
                "- power                         {:.2} W",
                pdo.power() as f32 / 4.0
            );
        }
        pdo::Pdo::Augmented(pdo) => {
            println!("- type                          Augmented");
            println!("- voltage:");
            println!(
                "  max                           {:.2} V",
                pdo.max_voltage() as f32 / 20.0
            );
            println!(
                "  min                           {:.2} V",
                pdo.min_voltage() as f32 / 20.0
            );
            println!(
                "- current                       {:.2} A",
                pdo.max_current() as f32 * 20.0
            );
        }
    }
}
